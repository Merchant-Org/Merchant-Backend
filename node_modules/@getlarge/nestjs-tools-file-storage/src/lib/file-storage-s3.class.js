"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorageS3 = void 0;
const node_stream_1 = require("node:stream");
const helpers_1 = require("./helpers");
const types_1 = require("./types");
function config(setup) {
    const { bucket, maxPayloadSize, credentials, endpoint, logger } = setup;
    const region = setup.region ?? FileStorageS3.extractRegionFromEndpoint(endpoint ?? '');
    if (!region) {
        throw new Error('AWS region is missing');
    }
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const loaderFn = () => require('@aws-sdk/client-s3');
    const { S3 } = (0, helpers_1.loadPackage)('@aws-sdk/client-s3', FileStorageS3.name, loaderFn);
    const s3 = new S3({
        /**
         * We cannot really make calls without credentials unless we use a workaround
         * @see https://github.com/aws/aws-sdk-js-v3/issues/2321
         */
        ...(credentials ? { credentials } : {}),
        region,
        ...(logger ? { logger } : {}),
    });
    const filePath = (options) => {
        const { fileName } = options;
        return `public/${fileName}`;
    };
    const limits = { fileSize: maxPayloadSize * 1024 * 1024 };
    return {
        s3,
        bucket,
        filePath,
        limits,
    };
}
function removeTrailingForwardSlash(x) {
    return x?.endsWith('/') ? x?.slice(0, -1) : x;
}
function addTrailingForwardSlash(x) {
    return x.endsWith('/') ? x : `${x}/`;
}
// TODO: control filesize limit
class FileStorageS3 {
    constructor(setup, factory) {
        this.config = typeof factory === 'function' ? factory(setup) : config(setup);
    }
    static extractRegionFromEndpoint(endpoint) {
        const match = endpoint?.match(/(?<=\.)[^.]+(?=\.amazonaws\.com)/);
        return match?.length ? match[0] : null;
    }
    transformFilePath(fileName, methodType, request, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    options = {}) {
        return typeof this.config.filePath === 'function'
            ? this.config.filePath({ fileName, methodType, request, ...options })
            : fileName;
    }
    async fileExists(args) {
        const { filePath, options = {}, request } = args;
        const { s3, bucket: Bucket } = this.config;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        try {
            await s3.headObject({ ...options, Key, Bucket });
            return true;
        }
        catch {
            return false;
        }
    }
    async moveFile(args) {
        const { filePath, newFilePath, options = {}, request } = args;
        const { s3, bucket: Bucket } = this.config;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        const newKey = await this.transformFilePath(newFilePath, types_1.MethodTypes.WRITE, request, options);
        await s3.copyObject({ ...options, Bucket, CopySource: `${Bucket}/${Key}`, Key: newKey });
        await s3.deleteObject({ ...options, Key, Bucket });
    }
    async upload(options) {
        const { s3, bucket: Bucket } = this.config;
        const { Upload } = await (0, helpers_1.loadPackage)('@aws-sdk/lib-storage', FileStorageS3.name, () => Promise.resolve().then(() => require('@aws-sdk/lib-storage')));
        return new Upload({ client: s3, params: { ...options, Bucket } }).done();
    }
    async uploadFile(args) {
        const { filePath, content, options = {}, request } = args;
        const { bucket: Bucket } = this.config;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.WRITE, request, options);
        await this.upload({ ...options, Bucket, Key, Body: content });
    }
    async uploadStream(args) {
        const { filePath, options = {}, request } = args;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.WRITE, request, options);
        const { bucket: Bucket } = this.config;
        const writeStream = new node_stream_1.PassThrough();
        this.upload({ ...options, Bucket, Key, Body: writeStream })
            .then(() => {
            writeStream.emit('done');
        })
            .catch((err) => {
            writeStream.emit('done', err);
        });
        return writeStream;
    }
    async downloadFile(args) {
        const { filePath, options = {}, request } = args;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        const { s3, bucket: Bucket } = this.config;
        const readable = (await s3.getObject({ ...options, Bucket, Key })).Body;
        const chunks = [];
        for await (const chunk of readable) {
            chunks.push(chunk);
        }
        return Buffer.concat(chunks);
    }
    async downloadStream(args) {
        const { filePath, options = {}, request } = args;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        const { s3, bucket: Bucket } = this.config;
        const object = await s3.getObject({ ...options, Bucket, Key });
        // from https://github.com/aws/aws-sdk-js-v3/issues/1877#issuecomment-755446927
        return object.Body;
    }
    async deleteFile(args) {
        const { filePath, options = {}, request } = args;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.DELETE, request, options);
        const { s3, bucket: Bucket } = this.config;
        await s3.deleteObject({ ...options, Bucket, Key });
        return true;
    }
    async getFileMeta(args) {
        const { filePath, options = {}, request } = args;
        const Key = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        const { s3, bucket: Bucket } = this.config;
        return s3.headObject({ ...options, Bucket, Key });
    }
    async deleteDir(args) {
        const { dirPath, options = {}, request } = args;
        const { s3, bucket: Bucket } = this.config;
        const listKey = await this.transformFilePath(dirPath, types_1.MethodTypes.DELETE, request);
        const listParams = {
            Bucket,
            Prefix: listKey,
        };
        // get list of objects in a dir, limited to 1000 items
        const listedObjects = await s3.listObjects(listParams);
        if (!listedObjects.Contents?.length) {
            return;
        }
        const deleteParams = {
            Bucket,
            Delete: {
                Objects: listedObjects.Contents.map(({ Key }) => ({
                    Key,
                })),
            },
            ...options,
        };
        await s3.deleteObjects(deleteParams);
        if (listedObjects.IsTruncated) {
            await this.deleteDir({ dirPath });
        }
    }
    async readDir(args) {
        const defaultSerializer = (list) => {
            const { CommonPrefixes, Contents, Prefix } = list;
            const filesAndFilders = [];
            //  add nested folders, CommonPrefixes contains <prefix>/<next nested dir>
            if (CommonPrefixes?.length) {
                const folders = CommonPrefixes.map((prefixObject) => {
                    const prefix = removeTrailingForwardSlash(prefixObject.Prefix) ?? '';
                    const key = listParams['Prefix'];
                    // If key exists, we are looking for a nested folder
                    return (key ? prefix.slice(key.length) : prefix);
                });
                filesAndFilders.push(...folders);
            }
            // adds filenames
            if (Contents?.length && Prefix) {
                const files = Contents.filter((file) => !!file.Key).map((file) => file.Key?.replace(Prefix, ''));
                filesAndFilders.push(...files);
            }
            return filesAndFilders;
        };
        const { dirPath, request, serializer = defaultSerializer, options = {} } = args;
        const { s3, bucket: Bucket } = this.config;
        const Key = await this.transformFilePath(dirPath, types_1.MethodTypes.READ, request);
        const listParams = {
            ...options,
            Bucket,
            Delimiter: '/',
        };
        // Passing in / as Key breaks the folder matching
        if (Key !== '/' && Key !== '') {
            listParams.Prefix = addTrailingForwardSlash(Key);
        }
        const listedObjects = await s3.listObjects(listParams);
        return serializer(listedObjects);
    }
}
exports.FileStorageS3 = FileStorageS3;
//# sourceMappingURL=file-storage-s3.class.js.map