"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorageLocal = void 0;
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const node_stream_1 = require("node:stream");
const types_1 = require("./types");
function config(setup) {
    const { maxPayloadSize, storagePath } = setup;
    const filePath = async (options) => {
        const { fileName, methodType } = options;
        // Normalize and resolve the path to prevent path traversal
        const safeFileName = (0, node_path_1.normalize)(fileName).replace(/^(\.\.(\/|\\|$))+/, '');
        const fullPath = (0, node_path_1.resolve)(storagePath, safeFileName);
        // Ensure the resolved path starts with the intended storagePath to prevent path traversal
        if (!fullPath.startsWith((0, node_path_1.resolve)(storagePath + node_path_1.sep))) {
            throw new Error('Invalid file path');
        }
        if (methodType === types_1.MethodTypes.WRITE) {
            const storageDir = (0, node_path_1.dirname)(fullPath);
            const storageExists = await (0, promises_1.access)(storageDir)
                .then(() => true)
                .catch(() => false);
            if (!storageExists) {
                await (0, promises_1.mkdir)(storageDir, { recursive: true });
            }
        }
        return Promise.resolve(fullPath);
    };
    const limits = { fileSize: maxPayloadSize * 1024 * 1024 };
    return { filePath, limits };
}
// TODO: control filesize limit
class FileStorageLocal {
    constructor(setup, factory) {
        this.config = typeof factory === 'function' ? factory(setup) : config(setup);
    }
    transformFilePath(fileName, methodType, request, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    options = {}) {
        return typeof this.config.filePath === 'function'
            ? this.config.filePath({ fileName, request, methodType, ...options })
            : fileName;
    }
    async fileExists(args) {
        const { filePath, options = {}, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        return new Promise((resolve) => (0, node_fs_1.stat)(fileName, (err) => (err ? resolve(false) : resolve(true))));
    }
    async moveFile(args) {
        const { filePath, newFilePath, request } = args;
        const oldFileName = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request);
        const newFileName = await this.transformFilePath(newFilePath, types_1.MethodTypes.WRITE, request);
        await (0, promises_1.rename)(oldFileName, newFileName);
    }
    async uploadFile(args) {
        const { filePath, content, options, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.WRITE, request, options);
        return (0, promises_1.writeFile)(fileName, content, options);
    }
    async uploadStream(args) {
        const { filePath, options, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.WRITE, request, options);
        const writeStream = (0, node_fs_1.createWriteStream)(fileName, options);
        (0, node_stream_1.finished)(writeStream, (err) => writeStream.emit('done', err));
        return writeStream;
    }
    async downloadFile(args) {
        const { filePath, options, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        return (0, promises_1.readFile)(fileName, options);
    }
    async downloadStream(args) {
        const { filePath, options, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request, options);
        return (0, node_fs_1.createReadStream)(fileName, options);
    }
    async deleteFile(args) {
        const { filePath, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.DELETE, request);
        return new Promise((resolve, reject) => (0, node_fs_1.unlink)(fileName, (err) => (err && err.message === 'EENOENT' ? reject(err) : resolve(true))));
    }
    async getFileMeta(args) {
        const { filePath, options, request } = args;
        const fileName = await this.transformFilePath(filePath, types_1.MethodTypes.READ, request);
        return (0, promises_1.stat)(fileName, options);
    }
    async deleteDir(args) {
        const { options = { recursive: true, force: true }, dirPath, request } = args;
        const dirName = await this.transformFilePath(dirPath, types_1.MethodTypes.DELETE, request);
        return (0, promises_1.rm)(dirName, options);
    }
    async readDir(args) {
        const defaultSerializer = (v) => v.map((val) => {
            if (val instanceof Buffer) {
                return val.toString();
            }
            else if (val instanceof node_fs_1.Dirent) {
                return val.name;
            }
            return val;
        });
        const { dirPath, request, serializer = defaultSerializer, options = {} } = args;
        try {
            const transformedDirPath = await this.transformFilePath(dirPath, types_1.MethodTypes.READ, request);
            const result = await (0, promises_1.readdir)(transformedDirPath, options);
            return serializer(result);
        }
        catch (err) {
            if (err && typeof err === 'object' && 'code' in err && err['code'] === 'ENOENT') {
                // ? return undefined or null?
                return [];
            }
            throw err;
        }
    }
}
exports.FileStorageLocal = FileStorageLocal;
//# sourceMappingURL=file-storage-fs.class.js.map