"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorageGoogle = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const node_stream_1 = require("node:stream");
const helpers_1 = require("./helpers");
const types_1 = require("./types");
function config(setup) {
    const { bucketName, keyFilename, maxPayloadSize, projectId } = setup;
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const loaderFn = () => require('@google-cloud/storage');
    const { Storage } = (0, helpers_1.loadPackage)('@google-cloud/storage', FileStorageGoogle.name, loaderFn);
    const storage = new Storage({
        ...(projectId ? { projectId } : {}),
        ...(keyFilename ? { keyFilename } : {}),
    });
    const filePath = (options) => {
        return options.fileName;
    };
    const limits = { fileSize: maxPayloadSize * 1024 * 1024 };
    return {
        storage,
        bucket: bucketName,
        filePath,
        limits,
    };
}
let FileStorageGoogle = class FileStorageGoogle {
    constructor(setup, factory) {
        this.config = typeof factory === 'function' ? factory(setup) : config(setup);
    }
    transformFilePath(fileName, methodType, request, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    options = {}) {
        return typeof this.config.filePath === 'function'
            ? this.config.filePath({ fileName, methodType, request, ...options })
            : fileName;
    }
    async fileExists(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.READ, request, options);
        const [exists] = await storage.bucket(bucket).file(filePath, options).exists(options);
        return exists;
    }
    async moveFile(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const oldFilePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.READ, request, options);
        const newFilePath = await this.transformFilePath(args.newFilePath, types_1.MethodTypes.WRITE, request, options);
        await storage.bucket(bucket).file(oldFilePath).move(newFilePath, options);
    }
    async uploadFile(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.WRITE, request, options);
        const file = storage.bucket(bucket).file(filePath, options);
        await file.save(args.content, options);
    }
    async uploadStream(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.WRITE, request, options);
        const file = storage.bucket(bucket).file(filePath, options);
        const writeStream = file.createWriteStream(options);
        (0, node_stream_1.finished)(writeStream, (err) => writeStream.emit('done', err));
        return writeStream;
    }
    async downloadFile(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.READ, request, options);
        const [content] = await storage.bucket(bucket).file(filePath).download(options);
        return content;
    }
    async downloadStream(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.READ, request, options);
        const readStream = storage.bucket(bucket).file(filePath, options).createReadStream(options);
        return readStream;
    }
    async deleteFile(args) {
        try {
            const { storage, bucket } = this.config;
            const { options = {}, request } = args;
            const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.DELETE, request, options);
            await storage.bucket(bucket).file(filePath).delete(options);
            return true;
        }
        catch {
            return false;
        }
    }
    async getFileMeta(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const filePath = await this.transformFilePath(args.filePath, types_1.MethodTypes.READ, request, options);
        const [metadata] = await storage.bucket(bucket).file(filePath).getMetadata(options);
        return metadata;
    }
    async deleteDir(args) {
        const { storage, bucket } = this.config;
        const { options = {}, request } = args;
        const prefix = await this.transformFilePath(args.dirPath, types_1.MethodTypes.DELETE, request, options);
        await storage.bucket(bucket).deleteFiles({ ...options, prefix });
    }
    // TODO: make default serializer compliant with the other readDir implementations
    async readDir(args) {
        const defaultSerializer = (res) => {
            return res[0].map((file) => (prefix ? file.name.replace(`${prefix}/`, '') : file.name));
        };
        const { storage, bucket } = this.config;
        const { dirPath, request, serializer = defaultSerializer, options = {} } = args;
        const prefix = await this.transformFilePath(dirPath, types_1.MethodTypes.READ, request, options);
        const response = await storage
            .bucket(bucket)
            .getFiles({ includeTrailingDelimiter: false, includeFoldersAsPrefixes: false, ...options, prefix });
        return serializer(response);
    }
};
exports.FileStorageGoogle = FileStorageGoogle;
exports.FileStorageGoogle = FileStorageGoogle = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [Object, Function])
], FileStorageGoogle);
//# sourceMappingURL=file-storage-google.class.js.map